(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{385:function(s,t,a){"use strict";a.r(t);var n=a(42),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"_12-延迟解析-v8-如何实现闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-延迟解析-v8-如何实现闭包"}},[s._v("#")]),s._v(" 12 | 延迟解析：V8 如何实现闭包")]),s._v(" "),a("p",[s._v("V8 执行 JS 代码需要经过两个阶段："),a("strong",[s._v("编译")]),s._v("和"),a("strong",[s._v("执行")]),s._v("。那么在编译阶段，V8 不会把所有的代码编译以后再执行。")]),s._v(" "),a("ul",[a("li",[s._v("首先，JS 的代码可能非常多，一次性都编译会增加编译时间，严重影响首次执行 JS 代码的速度。这样会出现卡顿。")]),s._v(" "),a("li",[s._v("其次，解析完成的字节码和编译完成的机器码都会放在内存当中，一次性编译会造成内存占用。")])]),s._v(" "),a("p",[s._v("所以 V8 实现了"),a("strong",[s._v("惰性解析")]),s._v("。就是解析器在解析的过程中，遇到函数声明，会跳过函数内部代码，并不会为其生成 AST 和 字节码，仅仅\n生成顶层代码的 AST 和字节码。")]),s._v(" "),a("h2",{attrs:{id:"一、惰性解析的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、惰性解析的过程"}},[s._v("#")]),s._v(" 一、惰性解析的过程")]),s._v(" "),a("p",[s._v("下面给出一段 JS 代码，看看 V8 是怎么处理的？")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" d "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" f "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" d "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" f "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("V8 处理时，会自上而下的解析，解析的过程中遇到 foo 函数，只是一个声明语句，V8就会将函数转化为函数对象。并没有解析和编译函数内部的代码。\n"),a("img",{attrs:{src:"/images/35ce3f6469a7024ca14d81b6c804044a.jpg",alt:"V8解析函数"}}),s._v("\n继续往下，由于后续的代码都是顶层的代码，所以 V8 会为他们生成抽象语法树。\n"),a("img",{attrs:{src:"/images/e52476efb6ef924e74f470ead4970262.jpg",alt:"生成顶层代码的抽象语法树"}}),s._v("\n代码解析完成以后，就会一步一步的执行表达式，接下来遇到 foo 函数的执行，就从函数对象中取出函数代码编译执行。")]),s._v(" "),a("p",[s._v("上面是一个惰性解析的大致过程，但是遇到闭包怎么办呢？")]),s._v(" "),a("h2",{attrs:{id:"二、拆解闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、拆解闭包"}},[s._v("#")]),s._v(" 二、拆解闭包")]),s._v(" "),a("p",[s._v("首先闭包有三个基础的特性：")]),s._v(" "),a("ul",[a("li",[s._v("第一 JavaScript 语言允许在函数内部定义新的函数")]),s._v(" "),a("li",[s._v("第二 可以在内部函数中访问父函数中定义的变量")]),s._v(" "),a("li",[s._v("第三 因为函数是一等公民，所以函数可以作为返回值")])]),s._v(" "),a("h2",{attrs:{id:"三、闭包给惰性解析带来的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、闭包给惰性解析带来的问题"}},[s._v("#")]),s._v(" 三、闭包给惰性解析带来的问题")]),s._v(" "),a("p",[s._v("下面写一个经典的闭包：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" d "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("inner")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" d"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" c\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" f "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("ul",[a("li",[s._v("V8 会将全局执行上下文压入到调用栈中,然后进入执行 foo 函数的调用过程")]),s._v(" "),a("li",[s._v("V8 会为 foo 函数创建执行上下文，执行上下文中包括了变量 d")]),s._v(" "),a("li",[s._v("然后将 foo 函数的执行上下文压入栈中")]),s._v(" "),a("li",[s._v("foo 函数执行结束之后，foo 函数执行上下文从栈中弹出,这时候 foo 执行上下文中的变量 d 也随之被销毁")]),s._v(" "),a("li",[s._v("这时候，由于 inner 函数被保存到全局变量中了,inner 函数使用了 foo 函数中的变量 d ...😁")])]),s._v(" "),a("p",[s._v("接下来问题就来了，在 foo 执行的阶段采用了惰性解析，不会解析 inner 函数的内容，怎么判断 inner 中使用了 foo 中的变量呢？")]),s._v(" "),a("p",[s._v("解决这个问题，V8 引入了预解析器。")]),s._v(" "),a("ul",[a("li",[s._v("第一判断当前函数是不是存在一些语法上的错误，如果有就抛出错误。")]),s._v(" "),a("li",[s._v("第二就是检查函数内部是否引用了外部变量，如果引用了，"),a("strong",[s._v("预解析器就会将栈中的变量复制到堆中")]),s._v("。")])]),s._v(" "),a("h2",{attrs:{id:"四、总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、总结"}},[s._v("#")]),s._v(" 四、总结")]),s._v(" "),a("p",[s._v("在编译阶段，v8不会对所有代码进行编译，要不然速度会很慢，严重影响用户体验，所以采用一种“惰性编译”或者“惰性解析”，也就是说 v8默认不会对函数内部的代码进行编译，只有当函数被执行前，才会进行编译。")]),s._v(" "),a("p",[s._v("而闭包的问题指的是：由于子函数使用到了父函数的变量，导致父函数在执行完成以后，它内部被子函数引用的变量无法及时在内存中被释放。")]),s._v(" "),a("p",[s._v("而闭包问题产生的根本原因是 javascript中本身的特性：")]),s._v(" "),a("ol",[a("li",[s._v("可以在 JavaScript 函数内部定义新的函数；")]),s._v(" "),a("li",[s._v("内部函数中访问父函数中定义的变量；")]),s._v(" "),a("li",[s._v("因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值。")])]),s._v(" "),a("p",[s._v("既然由于javascript本身的这种特性就会出现闭包的问题，那么我们就要想办法解决闭包问题，那么“预编译“ 或者“预解析” 就出现了，")]),s._v(" "),a("p",[s._v("预编译具体方案： 在编译阶段，v8不会完全不解析函数，而是预解析函数，简单理解来说，就是判断一下父函数中是否有被子函数饮用的变量，如果有的话，就需要把这个变量copy一份到 堆内存中，同时子函数本身也是一个对象，它会被存在堆内存中，这样即使父函数执行完成，内存被释放以后，子函数在执行的时候，依然可以从堆内存中访问copy过来的变量。")])])}),[],!1,null,null,null);t.default=r.exports}}]);