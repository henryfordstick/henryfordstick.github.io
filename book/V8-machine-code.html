<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>10 | 机器代码 | 渔网的收获</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/user.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.775e5fee.css" as="style"><link rel="preload" href="/assets/js/app.9b386d1b.js" as="script"><link rel="preload" href="/assets/js/2.1290589a.js" as="script"><link rel="preload" href="/assets/js/67.b05f626d.js" as="script"><link rel="prefetch" href="/assets/js/10.d4fd6e1a.js"><link rel="prefetch" href="/assets/js/11.cec0b26c.js"><link rel="prefetch" href="/assets/js/12.cfe082ab.js"><link rel="prefetch" href="/assets/js/13.d7965fc0.js"><link rel="prefetch" href="/assets/js/14.13937ab9.js"><link rel="prefetch" href="/assets/js/15.e7d21a6a.js"><link rel="prefetch" href="/assets/js/16.e512d704.js"><link rel="prefetch" href="/assets/js/17.17ea5aa5.js"><link rel="prefetch" href="/assets/js/18.dfdc2979.js"><link rel="prefetch" href="/assets/js/19.0bca1b56.js"><link rel="prefetch" href="/assets/js/20.49ee7c94.js"><link rel="prefetch" href="/assets/js/21.cb5aaadf.js"><link rel="prefetch" href="/assets/js/22.139dd8ed.js"><link rel="prefetch" href="/assets/js/23.668d8c19.js"><link rel="prefetch" href="/assets/js/24.1f69e1a6.js"><link rel="prefetch" href="/assets/js/25.ec50c290.js"><link rel="prefetch" href="/assets/js/26.1877f422.js"><link rel="prefetch" href="/assets/js/27.7cbb705b.js"><link rel="prefetch" href="/assets/js/28.dc0c1ae6.js"><link rel="prefetch" href="/assets/js/29.83db8bcb.js"><link rel="prefetch" href="/assets/js/3.48c1cda4.js"><link rel="prefetch" href="/assets/js/30.e8ddf7a6.js"><link rel="prefetch" href="/assets/js/31.9c40808a.js"><link rel="prefetch" href="/assets/js/32.56e09c78.js"><link rel="prefetch" href="/assets/js/33.dd9dc7b2.js"><link rel="prefetch" href="/assets/js/34.39830e06.js"><link rel="prefetch" href="/assets/js/35.623ee4c5.js"><link rel="prefetch" href="/assets/js/36.2e6f4434.js"><link rel="prefetch" href="/assets/js/37.a2391d90.js"><link rel="prefetch" href="/assets/js/38.a8d7051c.js"><link rel="prefetch" href="/assets/js/39.9449d59f.js"><link rel="prefetch" href="/assets/js/4.e8433513.js"><link rel="prefetch" href="/assets/js/40.f2bfbe0d.js"><link rel="prefetch" href="/assets/js/41.8863549d.js"><link rel="prefetch" href="/assets/js/42.312d3cbe.js"><link rel="prefetch" href="/assets/js/43.932c6a8d.js"><link rel="prefetch" href="/assets/js/44.1221b5fd.js"><link rel="prefetch" href="/assets/js/45.0b46675b.js"><link rel="prefetch" href="/assets/js/46.4fbe9815.js"><link rel="prefetch" href="/assets/js/47.c9a5a449.js"><link rel="prefetch" href="/assets/js/48.4c1ada7e.js"><link rel="prefetch" href="/assets/js/49.b4b9fca0.js"><link rel="prefetch" href="/assets/js/5.de4a9de9.js"><link rel="prefetch" href="/assets/js/50.fcb47497.js"><link rel="prefetch" href="/assets/js/51.3328fb99.js"><link rel="prefetch" href="/assets/js/52.f9f5a776.js"><link rel="prefetch" href="/assets/js/53.34e25f16.js"><link rel="prefetch" href="/assets/js/54.d89e9a54.js"><link rel="prefetch" href="/assets/js/55.e40ea719.js"><link rel="prefetch" href="/assets/js/56.7f655d3b.js"><link rel="prefetch" href="/assets/js/57.07093346.js"><link rel="prefetch" href="/assets/js/58.f2109b84.js"><link rel="prefetch" href="/assets/js/59.009cdaf5.js"><link rel="prefetch" href="/assets/js/6.79dcc546.js"><link rel="prefetch" href="/assets/js/60.645c6210.js"><link rel="prefetch" href="/assets/js/61.da57da9f.js"><link rel="prefetch" href="/assets/js/62.77acadd2.js"><link rel="prefetch" href="/assets/js/63.08e100a1.js"><link rel="prefetch" href="/assets/js/64.19414153.js"><link rel="prefetch" href="/assets/js/65.647131dc.js"><link rel="prefetch" href="/assets/js/66.ca68cf77.js"><link rel="prefetch" href="/assets/js/68.f1441111.js"><link rel="prefetch" href="/assets/js/69.b3ef9f5a.js"><link rel="prefetch" href="/assets/js/7.279b7b62.js"><link rel="prefetch" href="/assets/js/70.7ec1f141.js"><link rel="prefetch" href="/assets/js/71.9f29011e.js"><link rel="prefetch" href="/assets/js/72.9ab01620.js"><link rel="prefetch" href="/assets/js/73.09818812.js"><link rel="prefetch" href="/assets/js/74.c9725230.js"><link rel="prefetch" href="/assets/js/75.6b7e53a2.js"><link rel="prefetch" href="/assets/js/76.28974dcd.js"><link rel="prefetch" href="/assets/js/77.4b80795c.js"><link rel="prefetch" href="/assets/js/78.7c322081.js"><link rel="prefetch" href="/assets/js/79.b78a98e8.js"><link rel="prefetch" href="/assets/js/8.b7b5adde.js"><link rel="prefetch" href="/assets/js/9.6db004aa.js">
    <link rel="stylesheet" href="/assets/css/0.styles.775e5fee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">渔网的收获</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/arith/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div> <a href="https://github.com/henryfordstick" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/arith/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div> <a href="https://github.com/henryfordstick" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>《图解 Google V8》</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/V8-prepared-execution.html" class="sidebar-link">01 | V8 是如何执行一段 JS 代码的</a></li><li><a href="/book/V8-function.html" class="sidebar-link">02 | JS 函数的特点：函数即对象</a></li><li><a href="/book/V8-attributes.html" class="sidebar-link">03 | 快属性和慢属性</a></li><li><a href="/book/V8-Functional-expression.html" class="sidebar-link">04 | 函数表达式</a></li><li><a href="/book/V8-proto.html" class="sidebar-link">05 | 原型链</a></li><li><a href="/book/V8-scope.html" class="sidebar-link">06 | 作用域链</a></li><li><a href="/book/V8-typeChange.html" class="sidebar-link">07 | 类型转换</a></li><li><a href="/book/V8-d8.html" class="sidebar-link">08 | 使用 V8 的调试工具 d8</a></li><li><a href="/book/V8-runtime.html" class="sidebar-link">09 | 运行时环境</a></li><li><a href="/book/V8-machine-code.html" aria-current="page" class="active sidebar-link">10 | 机器代码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/V8-machine-code.html#一、源码编译成机器码" class="sidebar-link">一、源码编译成机器码</a></li><li class="sidebar-sub-header"><a href="/book/V8-machine-code.html#二、cpu-是怎么执行程序的" class="sidebar-link">二、CPU 是怎么执行程序的</a></li><li class="sidebar-sub-header"><a href="/book/V8-machine-code.html#三、总结" class="sidebar-link">三、总结</a></li></ul></li><li><a href="/book/V8-Stack-heap.html" class="sidebar-link">11 | 堆和栈</a></li><li><a href="/book/V8-closure.html" class="sidebar-link">12 | 延迟解析：V8 如何实现闭包</a></li><li><a href="/book/V8-bytecode-one.html" class="sidebar-link">13 | 字节码（一）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>《JavaScript 正则表达式迷你书》</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/regular-guide1.html" class="sidebar-link">第一章 正则表达式字符匹配攻略</a></li><li><a href="/book/regular-guide2.html" class="sidebar-link">第二章 正则表达式位置匹配攻略</a></li><li><a href="/book/regular-guide3.html" class="sidebar-link">第三章 正则表达式括号的作用</a></li><li><a href="/book/regular-guide4.html" class="sidebar-link">第四章 正则表达式回溯法原理</a></li><li><a href="/book/regular-guide5.html" class="sidebar-link">第五章 正则表达式的拆分</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>《看完够用的函数式编程》</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>《CSS 世界》</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>《图解 HTTP》</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_10-机器代码"><a href="#_10-机器代码" class="header-anchor">#</a> 10 | 机器代码</h1> <p>当 V8 准备好 runtime 以后，就可以执行 JS 代码了。V8 需要将 源代码 解析成字节码，然后执行，
或者将需要优化的代码直接编译成机器码，并直接执行机器码。</p> <p>字节码和机器码的执行方式是一样的。那么问题是 CPU 是怎么执行机器码（二进制代码的）？
<img src="/images/a20dec9ec8a84c8519dd1c4a18c2dda2.jpg" alt="CPU执行二进制代码"></p> <h2 id="一、源码编译成机器码"><a href="#一、源码编译成机器码" class="header-anchor">#</a> 一、源码编译成机器码</h2> <p>将一段 c 语言代码编译成汇编代码。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 在文件夹下创建 index.c 文件，内容如下：</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>先通过 GCC 编译器编译成 二进制文件，再反汇编成汇编代码（将汇编代码转换成机器代码称为<strong>汇编</strong>，反之机器码转化成汇编称为<strong>反汇编</strong>）。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>gcc -O0 -o code_prog index.c
objdump -d code_prog
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/images/45a51ccfeba212d1ccda8c669d317509.png" alt="机器码和汇编码"></p> <ul><li>上图中，左边就是编译生成的机器码，是使用十六进制来展示的（十六进制易读），</li> <li>中间部分是汇编代码，汇编采用<strong>助记符</strong>来编写代码，其内容和机器码是一一对应的。</li></ul> <h2 id="二、cpu-是怎么执行程序的"><a href="#二、cpu-是怎么执行程序的" class="header-anchor">#</a> 二、CPU 是怎么执行程序的</h2> <p>在讨论这个问题之前，我们看看典型的计算机系统的硬件组织结构。
<img src="/images/880dc63d333d8d18d8be9a473b15e06d.jpg" alt="计算机系统的硬件组织结构">
主要有 CPU，主存储器，各种 IO 总线，还有一些外部设备如硬盘，显示器，USB 等。</p> <p><strong>首先，在执行程序之前，需要将程序装进内存</strong>。</p> <div class="custom-block tip"><p class="custom-block-title">内存，内存地址和 CPU</p> <p>一个恰当的比喻：</p> <ul><li>把内存看成快递柜，当你需要寄件是，打开快递柜的第 100 单元格。</li> <li>当你需要取件时，打开快递柜的 105 号单元格取件。</li></ul> <p>这里的 <strong>快递柜</strong>，<strong>快递柜的每个单元格编号</strong> 和 <strong>操作快递柜的人</strong> 分别就是 <strong>内存</strong>，<strong>内存地址</strong>和<strong>CPU</strong>。</p> <p>也就是说，CPU 可以指定内存地址，从内存地址中读取数据，或者往内存地址中写入数据。</p> <p>有了内存地址，CPU 和内存可以有序的交互。</p></div> <p><strong>内存中的每个存储空间都有其对应的独一无二的地址</strong>。下图展示：
<img src="/images/87bfd9f3cd9a3e120e9e51a47fb4afe6.jpg" alt="内存中的存储空间都有唯一地址"></p> <p>一旦二级制代码装进内存，CPU 便可以从内存中<strong>取出一条指令</strong>，然后分析该指令，最后<strong>执行该指令</strong>。
（我们把取出指令，分析指令，执行指令三个过程称为<strong>CPU时钟周期</strong>）。CPU永不停歇，一直重改这个过程，直至所有的
指令执行完成。</p> <p>那么 CPU 是怎么知道要取出哪个内纯地址的指令呢？
<img src="/images/81f37939dc9920c1e0e261c7f345ceb3.jpg" alt="将混乱的二进制代码转换为有序的指令形式"></p> <p><strong>CPU 中是有一个 PC 寄存器，它保存了将要执行的指令地址</strong>。当机器码装进内存以后，系统会将机器码的第一条指令的地址
写入寄存器，下一个时钟周期 CPU 便根据 PC 寄存器中的地址，到内存中取出指令。</p> <p>PC 寄存器中的指令取出来以后，系统将干两件事：</p> <ul><li>第一将下一条指令的地址更新到 PC 寄存器中。</li> <li>第二 CPU 分析该指令并识别出不同的类型的指令，以及各种获取操作数的方法。
<img src="/images/10e900db99f77fa780ef4652b8302f42.jpg" alt="将下一条指令写入PC中"></li></ul> <p>那么 CPU 是如何执行指令的呢？</p> <p>这里需要一个重要部件：<strong>通用寄存器</strong> 是 CPU 存放数据的设备，不同处理器的寄存器个数是不一样的；因为 CPU 访问
内存的速度很慢，所以在 CPU 内部添加了一些存储设备，就叫通用寄存器。</p> <div class="custom-block tip"><p class="custom-block-title">通用寄存器和内存</p> <ul><li><strong>通用寄存器容量小，读写速度快，内存容量大，读写速度慢。</strong></li> <li>通常寄存器存储的数据是没有特别限制的（既可以存储数据，又可以存储指针）。但是因为历史原因，会将专用的数据放在专用的寄存器中。
<ul><li>rbp 寄存器通常是用来存放栈帧指针的。</li> <li>rsp 寄存器用来存放栈顶指针的。</li> <li>PC 寄存器用来存放下一条要执行的指令。</li></ul></li></ul></div> <p>常见的指令类型有哪些呢？</p> <p>第一种是<strong>加载指令</strong>，其作用是从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存器中原来的内容。
<img src="/images/c058013ef04fae7c1d5ff24cf0911fed.jpg" alt="更新PC寄存器">
如上图 <strong>movl</strong>指令，指令后面跟着的第一个参数是要拷贝数据的内存的位置，第二个参数是要拷贝到 ecx 这个寄存器。</p> <p>第二种是<strong>存储的指令</strong>，和加载类型的指令相反，其作用是将寄存器中的内容复制内存某个位置，并覆盖掉内存中的这个位置上原来的内容。
<img src="/images/5dc3e0cf2ffba709280bb852ea37891e.jpg" alt="存储的指令">
movl 指令后面的 %ecx 就是寄存器地址，-8(%rbp) 是内存中的地址，这条指令的作用是将寄存器中的值拷贝到内存中。</p> <p>第三种是<strong>更新指令</strong>，作用是复制两个寄存器中的内容到 ALU 中，也可以是一块寄存器和一块内存中的内容到 ALU 中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中，并覆盖该寄存器中的内容。
<img src="/images/8fde0c5d8d139060849531e5537111fb.jpg" alt="更新指令">
addl 指令，将寄存器 eax 和 ecx 中的值传给 ALU，ALU 对它们进行相加操纵，并将计算的结果写回 ecx。</p> <p>第四种是<strong>跳转指令</strong>，从指令本身抽取出一个字，这个字是下一条要执行的指令的地址，并将该字复制到 PC 寄存器中，并覆盖掉 PC 寄存器中原来的值。
<img src="/images/a69affcd27b2646fff920a0c0ab08aca.jpg" alt="跳转指令">
通过 jmp 来实现的，jmp 后面跟着要跳转的内存中的指令地址。</p> <p>第五种是<strong>IO 读 / 写指令</strong>，这些指令可以从一个 IO 设备中复制指定长度的数据到寄存器中，也可以将一个寄存器中的数据复制到指定的 IO 设备。</p> <h2 id="三、总结"><a href="#三、总结" class="header-anchor">#</a> 三、总结</h2> <p>CPU 执行二进制代码的过程如下：</p> <ol><li>二进制代码装载进内存，系统会将第一条指令的地址写入到 PC 寄存器中。</li> <li>读取指令：根据pc寄存器中地址，读取到第一条指令，并将pc寄存器中内容更新成下一条指令地址。</li> <li>分析指令：并识别出不同的类型的指令，以及各种获取操作数的方法。</li> <li>执行指令：由于cpu访问内存花费时间较长，因此cpu内部提供了通用寄存器，用来保存关键变量，临时数据等。指令包括加载指令，存储指令，更新指令，跳转指令。如果涉及加减运算，会额外让ALU进行运算。</li> <li>指令完成后，通过pc寄存器取出下一条指令地址，并更新pc寄存器中内容，再重复以上步骤。</li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/henryfordstick/edit/master/docs/book/V8-machine-code.md" target="_blank" rel="noopener noreferrer">本文源码地址</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">12/7/2020, 12:01:11 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book/V8-runtime.html" class="prev">
        09 | 运行时环境
      </a></span> <span class="next"><a href="/book/V8-Stack-heap.html">
        11 | 堆和栈
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9b386d1b.js" defer></script><script src="/assets/js/2.1290589a.js" defer></script><script src="/assets/js/67.b05f626d.js" defer></script>
  </body>
</html>
